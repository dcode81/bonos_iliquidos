# -*- coding: utf-8 -*-
"""Implementaci√≥n algoritmos sobre DataSet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uCv-hoz4AyJCTcrkjXc5TskcNA8GhrA5

# Implementaci√≥n de Algoritmos
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

# Machine Learning
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
import xgboost as xgb
from sklearn.metrics import mean_absolute_error, mean_squared_error
from sklearn.model_selection import GridSearchCV
import joblib

# Configuraci√≥n visual
plt.style.use('seaborn-v0_8-darkgrid')
sns.set_palette("husl")

print("‚úÖ Librer√≠as importadas")
print(f"üìÖ Fecha de ejecuci√≥n: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

# ============================================================================
# CLASE PARA CARGA DE DATOS
# ============================================================================

class BondDataLoader:
    """Carga y preprocesamiento de datos de bonos argentinos."""

    def __init__(self, filepath):
        self.filepath = filepath
        self.df_raw = None
        self.df_long = None

    def load_data(self):
        """Carga datos desde Excel."""
        print("üîÑ Cargando datos desde Excel...")
        self.df_raw = pd.read_excel(self.filepath)
        print(f"‚úÖ {self.df_raw.shape[0]} filas, {self.df_raw.shape[1]} columnas")
        return self.df_raw

    def transform_to_long_format(self):
        """Transforma de formato ancho a largo."""
        print("üîÑ Transformando a formato largo...")

        records = []
        for idx, row in self.df_raw.iterrows():
            fecha = row['fecha']

            for col in self.df_raw.columns:
                if col == 'fecha' or 'historico_' not in col:
                    continue

                parts = col.split('_')
                if len(parts) >= 3:
                    bond_name = parts[1]
                    metric = '_'.join(parts[2:])

                    if metric == 'ultimoPrecio':
                        precio_col = col
                        ops_col = f'historico_{bond_name}_cantidadOperaciones'

                        precio = row.get(precio_col)
                        operaciones = row.get(ops_col)

                        precio = float(precio) if pd.notna(precio) and precio != '' else None
                        operaciones = float(operaciones) if pd.notna(operaciones) and operaciones != '' else None

                        records.append({
                            'fecha': fecha,
                            'bond': bond_name,
                            'precio': precio,
                            'operaciones': operaciones
                        })

        self.df_long = pd.DataFrame(records)
        self.df_long['fecha'] = pd.to_datetime(self.df_long['fecha'])
        self.df_long = self.df_long.drop_duplicates()

        print(f"‚úÖ Formato largo: {len(self.df_long):,} observaciones")
        return self.df_long

    def calculate_liquidity_metrics(self):
        """Calcula m√©tricas de liquidez por bono."""
        print("üîÑ Calculando m√©tricas de liquidez...")

        liquidity_metrics = []
        for bond in self.df_long['bond'].unique():
            df_bond = self.df_long[self.df_long['bond'] == bond]

            total_days = len(df_bond)
            days_with_price = df_bond['precio'].notna().sum()
            days_with_ops = (df_bond['operaciones'] > 0).sum()

            liquidity_metrics.append({
                'bond': bond,
                'total_days': total_days,
                'days_with_price': days_with_price,
                'price_coverage': (days_with_price / total_days) * 100,
                'total_operations': df_bond['operaciones'].sum(),
                'avg_price': df_bond['precio'].mean()
            })

        df_liquidity = pd.DataFrame(liquidity_metrics)
        df_liquidity = df_liquidity.sort_values('price_coverage', ascending=False)

        print(f"‚úÖ M√©tricas para {len(df_liquidity)} bonos")
        return df_liquidity

print("‚úÖ Clase BondDataLoader definida")

# ============================================================================
# CLASE PARA AN√ÅLISIS EXPLORATORIO - COMPLETA
# ============================================================================

class BondEDA:
    """An√°lisis exploratorio de datos de bonos."""

    def __init__(self, df_long, df_liquidity):
        self.df_long = df_long
        self.df_liquidity = df_liquidity

    # ========================================================================
    # M√âTODOS ORIGINALES
    # ========================================================================

    def plot_liquidity_distribution(self):
        """Gr√°fico de distribuci√≥n de liquidez."""
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))

        # Histograma de cobertura
        axes[0, 0].hist(self.df_liquidity['price_coverage'], bins=30,
                       color='steelblue', edgecolor='black', alpha=0.7)
        axes[0, 0].axvline(70, color='green', linestyle='--', label='L√≠quido (70%)', linewidth=2)
        axes[0, 0].axvline(30, color='red', linestyle='--', label='Il√≠quido (30%)', linewidth=2)
        axes[0, 0].set_xlabel('Cobertura de Precios (%)')
        axes[0, 0].set_ylabel('Frecuencia')
        axes[0, 0].set_title('Distribuci√≥n de Cobertura de Precios', fontweight='bold')
        axes[0, 0].legend()
        axes[0, 0].grid(True, alpha=0.3)

        # Operaciones totales
        axes[0, 1].hist(np.log10(self.df_liquidity['total_operations'] + 1),
                       bins=30, color='coral', edgecolor='black', alpha=0.7)
        axes[0, 1].set_xlabel('log10(Total Operaciones + 1)')
        axes[0, 1].set_ylabel('Frecuencia')
        axes[0, 1].set_title('Distribuci√≥n de Volumen', fontweight='bold')
        axes[0, 1].grid(True, alpha=0.3)

        # Scatter
        scatter = axes[1, 0].scatter(self.df_liquidity['price_coverage'],
                                     self.df_liquidity['total_operations'],
                                     c=self.df_liquidity['price_coverage'],
                                     cmap='viridis', s=80, alpha=0.6)
        axes[1, 0].set_xlabel('Cobertura (%)')
        axes[1, 0].set_ylabel('Total Operaciones')
        axes[1, 0].set_title('Cobertura vs Volumen', fontweight='bold')
        axes[1, 0].set_yscale('log')
        axes[1, 0].grid(True, alpha=0.3)
        plt.colorbar(scatter, ax=axes[1, 0])

        # Estad√≠sticas
        axes[1, 1].axis('off')
        stats_text = f"""
        ESTAD√çSTICAS GENERALES

        Total bonos: {len(self.df_liquidity)}
        Cobertura promedio: {self.df_liquidity['price_coverage'].mean():.1f}%
        Cobertura mediana: {self.df_liquidity['price_coverage'].median():.1f}%

        Bonos l√≠quidos (‚â•70%): {(self.df_liquidity['price_coverage'] >= 70).sum()}
        Bonos il√≠quidos (<30%): {(self.df_liquidity['price_coverage'] < 30).sum()}
        """
        axes[1, 1].text(0.1, 0.5, stats_text, fontsize=12, family='monospace',
                       verticalalignment='center')

        plt.tight_layout()
        plt.show()

    def plot_time_series_sample(self, bonds, title="Series Temporales"):
        """Gr√°fica series de tiempo."""
        n_bonds = len(bonds)
        fig, axes = plt.subplots(n_bonds, 1, figsize=(14, 4*n_bonds), sharex=True)

        if n_bonds == 1:
            axes = [axes]

        for idx, bond in enumerate(bonds):
            df_bond = self.df_long[self.df_long['bond'] == bond].sort_values('fecha')

            axes[idx].plot(df_bond['fecha'], df_bond['precio'],
                          linewidth=1.5, color='steelblue', label='Precio')

            df_missing = df_bond[df_bond['precio'].isna()]
            if len(df_missing) > 0:
                axes[idx].scatter(df_missing['fecha'],
                                 [axes[idx].get_ylim()[1]*0.95]*len(df_missing),
                                 color='red', marker='v', s=20, alpha=0.3,
                                 label='Sin cotizaci√≥n')

            liq_info = self.df_liquidity[self.df_liquidity['bond'] == bond].iloc[0]
            axes[idx].set_title(f'{bond} - Cobertura: {liq_info["price_coverage"]:.1f}%',
                              fontweight='bold')
            axes[idx].set_ylabel('Precio (USD)')
            axes[idx].legend()
            axes[idx].grid(True, alpha=0.3)

        axes[-1].set_xlabel('Fecha')
        plt.tight_layout()
        plt.show()

    # ========================================================================
    # M√âTODOS NUEVOS - AN√ÅLISIS DE CORRELACIONES
    # ========================================================================

    def analyze_bond_correlations(self, liquid_bonds, illiquid_bonds, top_n=10):
        """
        Analiza correlaciones entre bonos l√≠quidos e il√≠quidos.

        Args:
            liquid_bonds: Lista de bonos l√≠quidos
            illiquid_bonds: Lista de bonos il√≠quidos
            top_n: N√∫mero de correlaciones m√°s altas a mostrar

        Returns:
            df_corr: DataFrame con todas las correlaciones
            best_proxies: DataFrame con mejor proxy por bono il√≠quido
        """
        print("\nüîó AN√ÅLISIS DE CORRELACIONES ENTRE BONOS")
        print("="*60)

        # Crear matriz de precios (pivote)
        df_pivot = self.df_long.pivot_table(
            index='fecha',
            columns='bond',
            values='precio'
        )

        # 1. MATRIZ DE CORRELACI√ìN COMPLETA
        corr_matrix = df_pivot.corr()

        # Visualizar matriz de correlaci√≥n
        plt.figure(figsize=(16, 14))

        # Separar bonos l√≠quidos e il√≠quidos en la visualizaci√≥n
        all_bonds = list(liquid_bonds) + list(illiquid_bonds)
        available_bonds = [b for b in all_bonds if b in corr_matrix.index]
        corr_subset = corr_matrix.loc[available_bonds, available_bonds]

        sns.heatmap(corr_subset,
                    cmap='RdYlGn',
                    center=0,
                    vmin=-1, vmax=1,
                    annot=False,
                    cbar_kws={'label': 'Correlaci√≥n'},
                    square=True)

        # Agregar l√≠neas separadoras
        n_liquid = len([b for b in liquid_bonds if b in available_bonds])
        plt.axhline(y=n_liquid, color='black', linewidth=3)
        plt.axvline(x=n_liquid, color='black', linewidth=3)

        plt.title('Matriz de Correlaci√≥n: Bonos L√≠quidos vs Il√≠quidos',
                  fontweight='bold', fontsize=14)
        plt.xlabel('Bonos')
        plt.ylabel('Bonos')

        # Etiquetas de secci√≥n
        plt.text(n_liquid/2, -2, 'L√çQUIDOS',
                ha='center', fontweight='bold', fontsize=12, color='green')
        plt.text(n_liquid + (len(available_bonds)-n_liquid)/2, -2, 'IL√çQUIDOS',
                ha='center', fontweight='bold', fontsize=12, color='red')

        plt.tight_layout()
        plt.show()

        # 2. TOP CORRELACIONES L√çQUIDO-IL√çQUIDO
        print(f"\nüìä TOP {top_n} CORRELACIONES L√çQUIDO ‚Üí IL√çQUIDO:")
        print("-"*60)

        correlations = []
        for illiq in illiquid_bonds:
            for liq in liquid_bonds:
                if illiq in corr_matrix.index and liq in corr_matrix.columns:
                    corr_val = corr_matrix.loc[illiq, liq]
                    if not pd.isna(corr_val):
                        correlations.append({
                            'Bono_Iliquido': illiq,
                            'Bono_Liquido': liq,
                            'Correlacion': corr_val
                        })

        df_corr = pd.DataFrame(correlations)
        df_corr = df_corr.sort_values('Correlacion', ascending=False)

        print(df_corr.head(top_n).to_string(index=False))

        # 3. GR√ÅFICO DE BARRAS - MEJOR PROXY POR BONO IL√çQUIDO
        print(f"\nüìà MEJOR PROXY L√çQUIDO PARA CADA BONO IL√çQUIDO:")
        print("-"*60)

        best_proxies = df_corr.loc[df_corr.groupby('Bono_Iliquido')['Correlacion'].idxmax()]
        best_proxies = best_proxies.sort_values('Correlacion', ascending=False)

        print(best_proxies.to_string(index=False))

        fig, ax = plt.subplots(figsize=(12, max(6, len(best_proxies)*0.4)))

        colors = ['green' if x > 0.7 else 'orange' if x > 0.5 else 'red'
                  for x in best_proxies['Correlacion']]

        bars = ax.barh(range(len(best_proxies)),
                       best_proxies['Correlacion'],
                       color=colors, alpha=0.7, edgecolor='black')

        ax.set_yticks(range(len(best_proxies)))
        ax.set_yticklabels([f"{row['Bono_Iliquido']} ‚Üí {row['Bono_Liquido']}"
                           for _, row in best_proxies.iterrows()])
        ax.set_xlabel('Correlaci√≥n', fontsize=12)
        ax.set_title('Mejor Proxy L√≠quido por Bono Il√≠quido',
                    fontweight='bold', fontsize=14)
        ax.axvline(0.7, color='green', linestyle='--', alpha=0.5, label='Alta (>0.7)')
        ax.axvline(0.5, color='orange', linestyle='--', alpha=0.5, label='Media (>0.5)')
        ax.grid(True, alpha=0.3, axis='x')
        ax.legend()
        ax.invert_yaxis()

        plt.tight_layout()
        plt.show()

        return df_corr, best_proxies

    def plot_comovement_analysis(self, illiquid_bond, liquid_bonds_top3):
        """
        Analiza co-movimiento entre un bono il√≠quido y sus mejores proxies l√≠quidos.

        Args:
            illiquid_bond: C√≥digo del bono il√≠quido
            liquid_bonds_top3: Lista con 3 bonos l√≠quidos m√°s correlacionados
        """
        print(f"\nüìâ CO-MOVIMIENTO: {illiquid_bond}")
        print("="*60)

        fig, axes = plt.subplots(2, 1, figsize=(14, 10), sharex=True)

        # 1. PRECIOS NORMALIZADOS
        ax = axes[0]

        colors_map = {illiquid_bond: 'darkred'}
        color_palette = ['steelblue', 'green', 'purple']

        for i, bond in enumerate([illiquid_bond] + liquid_bonds_top3):
            df_bond = self.df_long[self.df_long['bond'] == bond].sort_values('fecha')

            if len(df_bond) == 0:
                continue

            # Normalizar a 100 en primera observaci√≥n v√°lida
            first_price = df_bond['precio'].dropna().iloc[0] if df_bond['precio'].notna().any() else None

            if first_price is None or first_price == 0:
                continue

            normalized = (df_bond['precio'] / first_price) * 100

            style = '-' if bond == illiquid_bond else '--'
            linewidth = 2.5 if bond == illiquid_bond else 1.5
            alpha = 1.0 if bond == illiquid_bond else 0.6
            color = colors_map.get(bond, color_palette[i-1] if i > 0 else 'gray')

            ax.plot(df_bond['fecha'], normalized,
                   label=f"{bond} {'(IL√çQUIDO)' if bond == illiquid_bond else '(l√≠quido)'}",
                   linestyle=style, linewidth=linewidth, alpha=alpha, color=color)

        ax.axhline(100, color='black', linestyle=':', alpha=0.3)
        ax.set_ylabel('Precio Normalizado (Base 100)', fontsize=11)
        ax.set_title(f'Evoluci√≥n Comparada: {illiquid_bond} vs Proxies L√≠quidos',
                    fontweight='bold', fontsize=13)
        ax.legend(loc='best')
        ax.grid(True, alpha=0.3)

        # 2. RETORNOS DIARIOS
        ax = axes[1]

        for i, bond in enumerate([illiquid_bond] + liquid_bonds_top3):
            df_bond = self.df_long[self.df_long['bond'] == bond].sort_values('fecha')

            if len(df_bond) == 0:
                continue

            returns = df_bond['precio'].pct_change() * 100

            style = '-' if bond == illiquid_bond else '--'
            linewidth = 2.5 if bond == illiquid_bond else 1.5
            alpha = 1.0 if bond == illiquid_bond else 0.6
            color = colors_map.get(bond, color_palette[i-1] if i > 0 else 'gray')

            ax.plot(df_bond['fecha'], returns,
                   label=bond, linestyle=style,
                   linewidth=linewidth, alpha=alpha, color=color)

        ax.axhline(0, color='black', linestyle='-', linewidth=0.8, alpha=0.5)
        ax.set_xlabel('Fecha', fontsize=11)
        ax.set_ylabel('Retorno Diario (%)', fontsize=11)
        ax.set_title('Retornos Diarios Comparados', fontweight='bold', fontsize=13)
        ax.legend(loc='best')
        ax.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

    def analyze_market_features(self, liquid_bonds, illiquid_bonds):
        """
        Analiza caracter√≠sticas de mercado comparando l√≠quidos vs il√≠quidos.

        Returns:
            dict: Estad√≠sticas comparativas
        """
        print("\nüìä AN√ÅLISIS COMPARATIVO: L√çQUIDOS vs IL√çQUIDOS")
        print("="*60)

        df_liquid = self.df_long[self.df_long['bond'].isin(liquid_bonds)]
        df_illiquid = self.df_long[self.df_long['bond'].isin(illiquid_bonds)]

        fig, axes = plt.subplots(2, 3, figsize=(16, 10))

        # 1. Distribuci√≥n de Precios
        axes[0, 0].hist(df_liquid['precio'].dropna(), bins=50,
                       alpha=0.6, label='L√≠quidos', color='green', edgecolor='black')
        axes[0, 0].hist(df_illiquid['precio'].dropna(), bins=50,
                       alpha=0.6, label='Il√≠quidos', color='red', edgecolor='black')
        axes[0, 0].set_xlabel('Precio (USD)')
        axes[0, 0].set_ylabel('Frecuencia')
        axes[0, 0].set_title('Distribuci√≥n de Precios', fontweight='bold')
        axes[0, 0].legend()
        axes[0, 0].grid(True, alpha=0.3)

        # 2. Volatilidad (std de retornos)
        vol_liquid = df_liquid.groupby('bond')['precio'].apply(
            lambda x: x.pct_change().std() * 100
        ).dropna()
        vol_illiquid = df_illiquid.groupby('bond')['precio'].apply(
            lambda x: x.pct_change().std() * 100
        ).dropna()

        bp = axes[0, 1].boxplot([vol_liquid, vol_illiquid],
                          labels=['L√≠quidos', 'Il√≠quidos'],
                          patch_artist=True)
        for patch, color in zip(bp['boxes'], ['lightgreen', 'lightcoral']):
            patch.set_facecolor(color)
            patch.set_alpha(0.7)

        axes[0, 1].set_ylabel('Volatilidad Diaria (%)')
        axes[0, 1].set_title('Volatilidad por Grupo', fontweight='bold')
        axes[0, 1].grid(True, alpha=0.3, axis='y')

        # 3. Retorno Promedio
        ret_liquid = df_liquid.groupby('bond')['precio'].apply(
            lambda x: x.pct_change().mean() * 100
        ).dropna()
        ret_illiquid = df_illiquid.groupby('bond')['precio'].apply(
            lambda x: x.pct_change().mean() * 100
        ).dropna()

        bp2 = axes[0, 2].boxplot([ret_liquid, ret_illiquid],
                          labels=['L√≠quidos', 'Il√≠quidos'],
                          patch_artist=True)
        for patch, color in zip(bp2['boxes'], ['lightgreen', 'lightcoral']):
            patch.set_facecolor(color)
            patch.set_alpha(0.7)

        axes[0, 2].axhline(0, color='black', linestyle='--', linewidth=0.8)
        axes[0, 2].set_ylabel('Retorno Diario Promedio (%)')
        axes[0, 2].set_title('Retorno por Grupo', fontweight='bold')
        axes[0, 2].grid(True, alpha=0.3, axis='y')

        # 4. Precio Promedio por Fecha - Comparaci√≥n
        price_liquid = df_liquid.groupby('fecha')['precio'].mean()
        price_illiquid = df_illiquid.groupby('fecha')['precio'].mean()

        ax2 = axes[1, 0].twinx()
        axes[1, 0].plot(price_liquid.index, price_liquid,
                       color='green', label='L√≠quidos', linewidth=2)
        ax2.plot(price_illiquid.index, price_illiquid,
                color='red', label='Il√≠quidos', linewidth=2, alpha=0.7)

        axes[1, 0].set_xlabel('Fecha')
        axes[1, 0].set_ylabel('Precio Promedio - L√≠quidos', color='green')
        ax2.set_ylabel('Precio Promedio - Il√≠quidos', color='red')
        axes[1, 0].set_title('Evoluci√≥n Precio Promedio', fontweight='bold')
        axes[1, 0].grid(True, alpha=0.3)
        axes[1, 0].tick_params(axis='y', labelcolor='green')
        ax2.tick_params(axis='y', labelcolor='red')

        # Combinar leyendas
        lines1, labels1 = axes[1, 0].get_legend_handles_labels()
        lines2, labels2 = ax2.get_legend_handles_labels()
        axes[1, 0].legend(lines1 + lines2, labels1 + labels2, loc='best')

        # 5. D√≠as con/sin cotizaci√≥n
        days_liquid = df_liquid.groupby('bond').apply(
            lambda x: (x['precio'].notna().sum() / len(x)) * 100
        )
        days_illiquid = df_illiquid.groupby('bond').apply(
            lambda x: (x['precio'].notna().sum() / len(x)) * 100
        )

        axes[1, 1].hist(days_liquid, bins=20, alpha=0.6,
                       label='L√≠quidos', color='green', edgecolor='black')
        axes[1, 1].hist(days_illiquid, bins=20, alpha=0.6,
                       label='Il√≠quidos', color='red', edgecolor='black')
        axes[1, 1].set_xlabel('% D√≠as con Cotizaci√≥n')
        axes[1, 1].set_ylabel('Frecuencia')
        axes[1, 1].set_title('Cobertura Temporal', fontweight='bold')
        axes[1, 1].legend()
        axes[1, 1].grid(True, alpha=0.3)

        # 6. Tabla de estad√≠sticas
        axes[1, 2].axis('off')

        stats_text = f"""
        ESTAD√çSTICAS COMPARATIVAS

        L√çQUIDOS:
          Bonos: {len(liquid_bonds)}
          Precio promedio: ${df_liquid['precio'].mean():.2f}
          Volatilidad media: {vol_liquid.mean():.2f}%
          Retorno medio: {ret_liquid.mean():.4f}%

        IL√çQUIDOS:
          Bonos: {len(illiquid_bonds)}
          Precio promedio: ${df_illiquid['precio'].mean():.2f}
          Volatilidad media: {vol_illiquid.mean():.2f}%
          Retorno medio: {ret_illiquid.mean():.4f}%

        RATIO VOLATILIDAD:
          Il√≠q/L√≠q: {vol_illiquid.mean()/vol_liquid.mean() if vol_liquid.mean() > 0 else 0:.2f}x
        """

        axes[1, 2].text(0.1, 0.5, stats_text,
                       fontsize=10, family='monospace',
                       verticalalignment='center')

        plt.tight_layout()
        plt.show()

        # Retornar estad√≠sticas
        return {
            'liquid': {
                'n_bonds': len(liquid_bonds),
                'avg_price': df_liquid['precio'].mean(),
                'avg_volatility': vol_liquid.mean(),
                'avg_return': ret_liquid.mean()
            },
            'illiquid': {
                'n_bonds': len(illiquid_bonds),
                'avg_price': df_illiquid['precio'].mean(),
                'avg_volatility': vol_illiquid.mean(),
                'avg_return': ret_illiquid.mean()
            }
        }

print("‚úÖ Clase BondEDA completa definida")

# ============================================================================
# CLASE PARA FEATURE ENGINEERING
# ============================================================================

class BondFeatureEngineer:
    """Ingenier√≠a de features para modelos ML."""

    def __init__(self, df_long, liquid_bonds):
        self.df_long = df_long.copy()
        self.liquid_bonds = liquid_bonds

    def create_features(self):
        """Crea todos los features necesarios."""
        print("üîÑ Creando features...")

        df = self.df_long.sort_values(['bond', 'fecha'])

        # Features por bono
        for bond in df['bond'].unique():
            mask = df['bond'] == bond

            # Lags
            df.loc[mask, 'precio_lag1'] = df.loc[mask, 'precio'].shift(1)

            # Promedios m√≥viles
            df.loc[mask, 'precio_ma7'] = df.loc[mask, 'precio'].rolling(7, min_periods=1).mean()
            df.loc[mask, 'precio_ma30'] = df.loc[mask, 'precio'].rolling(30, min_periods=1).mean()

            # Volatilidad
            df.loc[mask, 'precio_std7'] = df.loc[mask, 'precio'].rolling(7, min_periods=1).std()

            # Retorno
            df.loc[mask, 'retorno_diario'] = df.loc[mask, 'precio'].pct_change()

        # Features de mercado (bonos l√≠quidos)
        df_liquid = df[df['bond'].isin(self.liquid_bonds)]
        market_features = df_liquid.groupby('fecha').agg({
            'precio': ['mean', 'std'],
            'operaciones': 'sum'
        }).reset_index()
        market_features.columns = ['fecha', 'mercado_precio_mean', 'mercado_precio_std', 'mercado_ops']

        df = df.merge(market_features, on='fecha', how='left')

        # Features temporales
        df['mes'] = df['fecha'].dt.month
        df['dia_semana'] = df['fecha'].dt.dayofweek

        # Caracter√≠sticas del bono
        df['es_liquido'] = df['bond'].isin(self.liquid_bonds).astype(int)

        # Target - NORMALIZACI√ìN Z-SCORE
        print("üîÑ Normalizando precios por bono...")

        # Calcular estad√≠sticas por bono
        df['precio_mean'] = df.groupby('bond')['precio'].transform('mean')
        df['precio_std'] = df.groupby('bond')['precio'].transform('std')

        # Normalizar: (precio - media) / desviaci√≥n est√°ndar
        df['precio_normalizado'] = (df['precio'] - df['precio_mean']) / (df['precio_std'] + 1e-10)

        # Usar precio normalizado como target
        df['target'] = df['precio_normalizado']

        # Guardar precio original para desnormalizar despu√©s
        df['precio_original'] = df['precio']

        print(f"‚úÖ Features creados y precios normalizados")
        print(f"   Rango normalizado: [{df['target'].min():.2f}, {df['target'].max():.2f}]")

        return df

print("‚úÖ Clase BondFeatureEngineer definida")

# ============================================================================
# CLASE PARA MODELADO
# ============================================================================

class BondPriceModel:
    """Modelo de predicci√≥n de precios de bonos."""

    def __init__(self, model_type='random_forest'):
        self.model_type = model_type
        self.model = None
        self.feature_importance = None

    def train(self, X_train, y_train, X_val=None, y_val=None, params=None):
        """Entrena el modelo."""
        print(f"\nüéØ Entrenando: {self.model_type.upper()}")

        if params is None:
            params = {}

        if self.model_type == 'decision_tree':
            default = {'max_depth': 10, 'min_samples_split': 50, 'random_state': 42}
            default.update(params)
            self.model = DecisionTreeRegressor(**default)

        elif self.model_type == 'random_forest':
            default = {'n_estimators': 100, 'max_depth': 15, 'min_samples_split': 20,
                      'random_state': 42, 'n_jobs': -1}
            default.update(params)
            self.model = RandomForestRegressor(**default)

        elif self.model_type == 'xgboost':
            default = {'n_estimators': 100, 'max_depth': 6, 'learning_rate': 0.1,
                      'random_state': 42, 'n_jobs': -1}
            default.update(params)
            self.model = xgb.XGBRegressor(**default)

        self.model.fit(X_train, y_train)

        if hasattr(self.model, 'feature_importances_'):
            self.feature_importance = pd.DataFrame({
                'feature': X_train.columns,
                'importance': self.model.feature_importances_
            }).sort_values('importance', ascending=False)

        # Evaluar
        y_train_pred = self.model.predict(X_train)
        train_mae = mean_absolute_error(y_train, y_train_pred)
        print(f"   Train MAE: ${train_mae:.2f}")

        if X_val is not None:
            y_val_pred = self.model.predict(X_val)
            val_mae = mean_absolute_error(y_val, y_val_pred)
            print(f"   Val MAE:   ${val_mae:.2f}")

    def predict(self, X):
        """Realiza predicciones."""
        return self.model.predict(X)

    def evaluate(self, X, y, name="Test", y_real=None, precio_mean=None, precio_std=None):
        """Eval√∫a el modelo con m√©tricas apropiadas para predicci√≥n de precios."""
        y_pred = self.predict(X)

        # Si se proporcionan datos para desnormalizar, usarlos
        if y_real is not None and precio_mean is not None and precio_std is not None:
            # Desnormalizar predicciones
            y_pred_real = y_pred * precio_std + precio_mean

            # Calcular m√©tricas en escala real
            mae = mean_absolute_error(y_real, y_pred_real)
            rmse = np.sqrt(mean_squared_error(y_real, y_pred_real))

            # MAPE ajustado (excluyendo valores < 0.10)
            mask_validos = y_real >= 0.10
            if mask_validos.sum() > 0:
                mape = np.mean(np.abs((y_real[mask_validos] - y_pred_real[mask_validos]) / (y_real[mask_validos] + 1e-10))) * 100
            else:
                mape = np.mean(np.abs((y_real - y_pred_real) / (y_real + 1e-10))) * 100

            print(f"\nüìä M√©tricas en {name} (escala real USD):")
            print(f"   MAE (Error promedio):      ${mae:.4f}")
            print(f"   RMSE (Error cuadr√°tico):   ${rmse:.4f}")
            print(f"   MAPE ajustado (‚â•$0.10):    {mape:.4f}%")
        else:
            # M√©tricas en escala normalizada (train/val)
            mae = mean_absolute_error(y, y_pred)
            rmse = np.sqrt(mean_squared_error(y, y_pred))
            mape = np.mean(np.abs((y - y_pred) / (y + 1e-10))) * 100

            print(f"\nüìä M√©tricas en {name}:")
            print(f"   MAE (Error promedio):      ${mae:.2f}")
            print(f"   RMSE (Error cuadr√°tico):   ${rmse:.2f}")
            print(f"   MAPE (Error porcentual):   {mape:.2f}%")

        return {'MAE': mae, 'RMSE': rmse, 'MAPE': mape}

    def plot_predictions(self, X, y_true, title="Predicciones"):
        """Gr√°fica predicciones vs reales."""
        y_pred = self.predict(X)

        fig, axes = plt.subplots(1, 2, figsize=(14, 5))

        # Scatter
        axes[0].scatter(y_true, y_pred, alpha=0.5, s=30)
        min_val = min(y_true.min(), y_pred.min())
        max_val = max(y_true.max(), y_pred.max())
        axes[0].plot([min_val, max_val], [min_val, max_val], 'r--', lw=2)
        axes[0].set_xlabel('Precio Real')
        axes[0].set_ylabel('Precio Predicho')
        axes[0].set_title(f'{title} - {self.model_type}', fontweight='bold')
        axes[0].grid(True, alpha=0.3)

        # Residuos
        residuals = y_true - y_pred
        axes[1].hist(residuals, bins=50, color='coral', edgecolor='black', alpha=0.7)
        axes[1].axvline(0, color='red', linestyle='--', lw=2)
        axes[1].set_xlabel('Residuos')
        axes[1].set_ylabel('Frecuencia')
        axes[1].set_title('Distribuci√≥n de Residuos', fontweight='bold')
        axes[1].grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

print("‚úÖ Clase BondPriceModel definida")

# ============================================================================
# TODAS LAS CLASES EST√ÅN DEFINIDAS. AHORA VIENE EL C√ìDIGO PRINCIPAL
# ============================================================================

print("\n" + "="*80)
print(" "*15 + "EJECUCI√ìN DEL PIPELINE COMPLETO")
print("="*80)

# ============================================================================
# CARGA DE DATOS
# ============================================================================

print("\nüìÇ PASO 1: CARGA DE DATOS")
print("="*60)

# IMPORTANTE: Aseg√∫rate de subir el archivo Excel a Colab primero
FILENAME = 'historico_bonos_en_un_solo_archivo.xlsx'

loader = BondDataLoader(FILENAME)
df_raw = loader.load_data()
df_long = loader.transform_to_long_format()
df_liquidity = loader.calculate_liquidity_metrics()

print(f"\n‚úÖ Datos cargados:")
print(f"   Per√≠odo: {df_long['fecha'].min().date()} a {df_long['fecha'].max().date()}")
print(f"   Total observaciones: {len(df_long):,}")
print(f"   Bonos √∫nicos: {df_long['bond'].nunique()}")

# ============================================================================
#  CLASIFICACI√ìN DE BONOS
# ============================================================================

print("\nüè∑Ô∏è PASO 2: CLASIFICACI√ìN DE BONOS")
print("="*60)

LIQUID_THRESHOLD = 70.0
ILLIQUID_THRESHOLD = 30.0

liquid_bonds = df_liquidity[df_liquidity['price_coverage'] >= LIQUID_THRESHOLD]['bond'].tolist()
illiquid_bonds = df_liquidity[df_liquidity['price_coverage'] < ILLIQUID_THRESHOLD]['bond'].tolist()
intermediate_bonds = df_liquidity[
    (df_liquidity['price_coverage'] >= ILLIQUID_THRESHOLD) &
    (df_liquidity['price_coverage'] < LIQUID_THRESHOLD)
]['bond'].tolist()

print(f"üü¢ Bonos l√≠quidos (‚â•{LIQUID_THRESHOLD}%): {len(liquid_bonds)}")
print(f"üü° Bonos intermedios: {len(intermediate_bonds)}")
print(f"üî¥ Bonos il√≠quidos (<{ILLIQUID_THRESHOLD}%): {len(illiquid_bonds)}")

print(f"\nTop 10 bonos M√ÅS l√≠quidos:")
display(df_liquidity.head(10)[['bond', 'price_coverage', 'total_operations', 'avg_price']])

print(f"\nTop 10 bonos MENOS l√≠quidos:")
display(df_liquidity.tail(10)[['bond', 'price_coverage', 'total_operations', 'avg_price']])

# ============================================================================
# AN√ÅLISIS EXPLORATORIO
# ============================================================================

print("\nüìä PASO 3: AN√ÅLISIS EXPLORATORIO")
print("="*60)

eda = BondEDA(df_long, df_liquidity)

# Gr√°fico de distribuci√≥n
eda.plot_liquidity_distribution()

# Series temporales de bonos l√≠quidos
print("\nSeries temporales - Bonos l√≠quidos (muestra):")
eda.plot_time_series_sample(liquid_bonds[:3], "Bonos L√≠quidos - Top 3")

# Series temporales de bonos il√≠quidos
print("\nSeries temporales - Bonos il√≠quidos (muestra):")
eda.plot_time_series_sample(illiquid_bonds[:3], "Bonos Il√≠quidos - Muestra")

# ============================================================================
# NUEVO: AN√ÅLISIS DE CORRELACIONES Y PATRONES
# ============================================================================

print("\nüîó PASO 3.1: AN√ÅLISIS DE CORRELACIONES Y PATRONES")
print("="*60)

# 1. An√°lisis de correlaciones
df_correlations, best_proxies = eda.analyze_bond_correlations(
    liquid_bonds,
    illiquid_bonds,
    top_n=15
)

# Guardar resultados
best_proxies.to_csv('mejores_proxies_liquidos.csv', index=False)
print("\n‚úÖ Mejores proxies guardados en: mejores_proxies_liquidos.csv")

# 2. An√°lisis de co-movimiento para bonos il√≠quidos de ejemplo
print("\n" + "="*60)
print("AN√ÅLISIS DE CO-MOVIMIENTO (MUESTRA)")
print("="*60)

for illiquid_bond in illiquid_bonds[:min(3, len(illiquid_bonds))]:
    # Obtener mejores 3 proxies para este bono
    top3_proxies = df_correlations[
        df_correlations['Bono_Iliquido'] == illiquid_bond
    ].nlargest(3, 'Correlacion')['Bono_Liquido'].tolist()

    if len(top3_proxies) >= 3:
        eda.plot_comovement_analysis(illiquid_bond, top3_proxies)

# 3. An√°lisis comparativo de mercado
print("\n" + "="*60)
market_stats = eda.analyze_market_features(liquid_bonds, illiquid_bonds)

print("\nüìä RESUMEN DE ESTAD√çSTICAS:")
print(f"L√≠quidos - Volatilidad promedio: {market_stats['liquid']['avg_volatility']:.2f}%")
print(f"Il√≠quidos - Volatilidad promedio: {market_stats['illiquid']['avg_volatility']:.2f}%")
print(f"Ratio: {market_stats['illiquid']['avg_volatility']/market_stats['liquid']['avg_volatility']:.2f}x")

print("\n‚úÖ An√°lisis de correlaciones y patrones completado")

# ============================================================================
# FEATURE ENGINEERING
# ============================================================================

print("\nüõ†Ô∏è PASO 4: FEATURE ENGINEERING")
print("="*60)

engineer = BondFeatureEngineer(df_long, liquid_bonds)
df_features = engineer.create_features()

# Eliminar NaN
df_features = df_features.dropna()

print(f"‚úÖ Dataset con features creado: {df_features.shape}")
print(f"   Total features: {len([c for c in df_features.columns if c not in ['fecha', 'bond', 'target']])}")

# ============================================================================
# DIVISI√ìN TEMPORAL DE DATOS
# ============================================================================

print("\n‚úÇÔ∏è PASO 5: DIVISI√ìN TEMPORAL DEL DATASET")
print("="*60)

VAL_DATE = '2024-07-01'
TEST_DATE = '2024-10-01'

df_features['fecha'] = pd.to_datetime(df_features['fecha'])

# Divisi√≥n temporal
df_train = df_features[df_features['fecha'] < VAL_DATE].copy()
df_val = df_features[(df_features['fecha'] >= VAL_DATE) &
                     (df_features['fecha'] < TEST_DATE)].copy()
df_test = df_features[df_features['fecha'] >= TEST_DATE].copy()

print(f"üìÖ Train: {df_train['fecha'].min().date()} a {df_train['fecha'].max().date()} | {len(df_train):,} obs")
print(f"üìÖ Val:   {df_val['fecha'].min().date()} a {df_val['fecha'].max().date()} | {len(df_val):,} obs")
print(f"üìÖ Test:  {df_test['fecha'].min().date()} a {df_test['fecha'].max().date()} | {len(df_test):,} obs")

# Separar l√≠quidos e il√≠quidos
train_liquid = df_train[df_train['bond'].isin(liquid_bonds)].copy()
val_liquid = df_val[df_val['bond'].isin(liquid_bonds)].copy()
test_illiquid = df_test[df_test['bond'].isin(illiquid_bonds)].copy()

print(f"\nüéØ DATASETS PARA MODELADO:")
print(f"   Train (l√≠quidos): {len(train_liquid):,} obs, {train_liquid['bond'].nunique()} bonos")
print(f"   Val (l√≠quidos): {len(val_liquid):,} obs, {val_liquid['bond'].nunique()} bonos")
print(f"   Test (il√≠quidos): {len(test_illiquid):,} obs, {test_illiquid['bond'].nunique()} bonos")

# ============================================================================
# PREPARACI√ìN DE FEATURES
# ============================================================================

# Definir columnas de features
exclude_cols = ['fecha', 'bond', 'precio', 'target', 'operaciones']
feature_cols = [col for col in df_features.columns if col not in exclude_cols]

print(f"\nüìã Features para modelado: {len(feature_cols)}")
print("Primeros 10 features:")
for i, feat in enumerate(feature_cols[:10], 1):
    print(f"   {i}. {feat}")

# Preparar X, y
X_train = train_liquid[feature_cols]
y_train = train_liquid['target']

X_val = val_liquid[feature_cols]
y_val = val_liquid['target']

X_test = test_illiquid[feature_cols]
y_test = test_illiquid['target']

print(f"\n‚úÖ Datos preparados para entrenamiento")

# ============================================================================
# ENTRENAMIENTO DE MODELOS
# ============================================================================

print("\nü§ñ PASO 6: ENTRENAMIENTO DE MODELOS")
print("="*60)

# 1. Decision Tree
print("\n" + "-"*60)
dt_model = BondPriceModel('decision_tree')
dt_model.train(X_train, y_train, X_val, y_val,
               params={'max_depth': 12, 'min_samples_split': 30})

# 2. Random Forest
print("\n" + "-"*60)
rf_model = BondPriceModel('random_forest')
rf_model.train(X_train, y_train, X_val, y_val,
               params={'n_estimators': 150, 'max_depth': 15})

# 3. XGBoost
print("\n" + "-"*60)
xgb_model = BondPriceModel('xgboost')
xgb_model.train(X_train, y_train, X_val, y_val,
                params={'n_estimators': 200, 'max_depth': 6, 'learning_rate': 0.05})

print("\n‚úÖ Todos los modelos entrenados")

# ============================================================================
# EVALUACI√ìN EN BONOS IL√çQUIDOS
# ============================================================================

print("\nüéØ PASO 7: EVALUACI√ìN EN BONOS IL√çQUIDOS (OBJETIVO PRINCIPAL)")
print("="*60)

print(f"\nDataset de prueba:")
print(f"   Observaciones: {len(X_test):,}")
print(f"   Bonos il√≠quidos √∫nicos: {test_illiquid['bond'].nunique()}")
print(f"   Precio promedio real: ${y_test.mean():.2f}")

# Preparar datos reales para evaluaci√≥n correcta
print("\nüîÑ Preparando datos para evaluaci√≥n en escala real...")
test_illiquid['precio_real'] = test_illiquid['precio_original']

# Evaluar cada modelo
models = {
    'Decision Tree': dt_model,
    'Random Forest': rf_model,
    'XGBoost': xgb_model
}

results = {}
for name, model in models.items():
    print(f"\n{'-'*60}")
    # Pasar datos reales para desnormalizaci√≥n correcta
    metrics = model.evaluate(
        X_test, y_test, name,
        y_real=test_illiquid['precio_real'].values,
        precio_mean=test_illiquid['precio_mean'].values,
        precio_std=test_illiquid['precio_std'].values
    )
    results[name] = metrics

# ============================================================================
# COMPARACI√ìN DE MODELOS
# ============================================================================

print("\nüìä PASO 8: COMPARACI√ìN DE MODELOS")
print("="*60)

df_comparison = pd.DataFrame(results).T
df_comparison = df_comparison.reset_index()
df_comparison.columns = ['Modelo', 'MAE', 'RMSE', 'MAPE']

print("\nüèÜ TABLA COMPARATIVA:")
display(df_comparison.style.format({
    'MAE': '${:.2f}',
    'RMSE': '${:.2f}',
    'MAPE': '{:.2f}%'
}).background_gradient(subset=['MAE'], cmap='Greens'))

# Gr√°fico comparativo
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

metrics = ['MAE', 'RMSE',  'MAPE']
titles = ['MAE (menor mejor)', 'RMSE (menor mejor)', 'MAPE % (menor mejor)']
colors = ['steelblue', 'coral', 'green', 'purple']

for idx, (metric, title, color) in enumerate(zip(metrics, titles, colors)):
    ax = axes[idx // 2, idx % 2]

    df_plot = df_comparison[['Modelo', metric]].sort_values(
        metric, ascending=(metric != 'R¬≤')
    )

    ax.barh(df_plot['Modelo'], df_plot[metric], color=color, alpha=0.7, edgecolor='black')
    ax.set_xlabel(metric, fontsize=11)
    ax.set_title(title, fontsize=12, fontweight='bold')
    ax.grid(True, alpha=0.3, axis='x')

plt.tight_layout()
plt.show()

# Identificar mejor modelo
best_model_mae = df_comparison.loc[df_comparison['MAE'].idxmin(), 'Modelo']

print(f"\nüèÜ MEJORES MODELOS:")
print(f"   Menor MAE: {best_model_mae}")

# ============================================================================
# VISUALIZACI√ìN DE PREDICCIONES
# ============================================================================

print("\nüìà PASO 9: VISUALIZACI√ìN DE PREDICCIONES")
print("="*60)

# Predicciones de cada modelo
for name, model in models.items():
    print(f"\n{name}:")
    model.plot_predictions(X_test, y_test, f"Bonos Il√≠quidos - {name}")

# ============================================================================
#  FEATURE IMPORTANCE
# ============================================================================

print("\nüîç PASO 10: IMPORTANCIA DE FEATURES")
print("="*60)

for name, model in models.items():
    if model.feature_importance is not None:
        print(f"\n{name} - Top 15 Features:")

        top_features = model.feature_importance.head(15)

        fig, ax = plt.subplots(figsize=(10, 6))
        ax.barh(range(len(top_features)), top_features['importance'], color='steelblue')
        ax.set_yticks(range(len(top_features)))
        ax.set_yticklabels(top_features['feature'])
        ax.set_xlabel('Importancia')
        ax.set_title(f'Top 15 Features - {name}', fontweight='bold', fontsize=14)
        ax.invert_yaxis()
        ax.grid(True, alpha=0.3, axis='x')
        plt.tight_layout()
        plt.show()

# ============================================================================
# AN√ÅLISIS DETALLADO POR BONO
# ============================================================================

print("\nüî¨ PASO 11: AN√ÅLISIS DETALLADO POR BONO")
print("="*60)

# Usar el mejor modelo (Random Forest generalmente)
best_model = rf_model

y_pred_normalizado = best_model.predict(X_test)

print("\nüîÑ Desnormalizando predicciones a escala USD...")

# Guardar predicci√≥n normalizada
test_illiquid['pred_normalizado'] = y_pred_normalizado

# DESNORMALIZAR: precio = (valor_normalizado √ó std) + media
test_illiquid['precio_predicho'] = (
    test_illiquid['pred_normalizado'] * test_illiquid['precio_std'] +
    test_illiquid['precio_mean']
)

# Usar precio original para calcular errores
test_illiquid['precio_real'] = test_illiquid['precio_original']

# Calcular errores en escala original (USD)
test_illiquid['error_absoluto'] = np.abs(
    test_illiquid['precio_real'] - test_illiquid['precio_predicho']
)
test_illiquid['error_porcentual'] = (
    test_illiquid['error_absoluto'] / (test_illiquid['precio_real'] + 1e-10)
) * 100

# Calcular m√©tricas generales
mae_usd = test_illiquid['error_absoluto'].mean()
rmse_usd = np.sqrt((test_illiquid['error_absoluto'] ** 2).mean())

# MAPE estratificado por rango de precios
mask_muy_baratos = test_illiquid['precio_real'] < 0.10
mask_baratos = (test_illiquid['precio_real'] >= 0.10) & (test_illiquid['precio_real'] < 1.0)
mask_normales = (test_illiquid['precio_real'] >= 1.0) & (test_illiquid['precio_real'] < 100)
mask_caros = test_illiquid['precio_real'] >= 100

print(f"\nüìä M√âTRICAS DEL MEJOR MODELO EN ESCALA REAL (USD):")
print(f"   MAE:  ${mae_usd:.4f}")
print(f"   RMSE: ${rmse_usd:.4f}")

print(f"\nüìä MAPE POR RANGO DE PRECIOS:")
if mask_muy_baratos.sum() > 0:
    mape_muy_baratos = test_illiquid[mask_muy_baratos]['error_porcentual'].mean()
    print(f"   Bonos < $0.10      (n={mask_muy_baratos.sum():3d}): {mape_muy_baratos:8.2f}% ‚ö†Ô∏è")

if mask_baratos.sum() > 0:
    mape_baratos = test_illiquid[mask_baratos]['error_porcentual'].mean()
    print(f"   Bonos $0.10-$1     (n={mask_baratos.sum():3d}): {mape_baratos:8.2f}%")

if mask_normales.sum() > 0:
    mape_normales = test_illiquid[mask_normales]['error_porcentual'].mean()
    print(f"   Bonos $1-$100      (n={mask_normales.sum():3d}): {mape_normales:8.2f}% ‚úÖ")

if mask_caros.sum() > 0:
    mape_caros = test_illiquid[mask_caros]['error_porcentual'].mean()
    print(f"   Bonos > $100       (n={mask_caros.sum():3d}): {mape_caros:8.2f}% ‚úÖ")

# MAPE promedio excluyendo muy baratos
mask_validos = test_illiquid['precio_real'] >= 0.10
mape_valido = test_illiquid[mask_validos]['error_porcentual'].mean() if mask_validos.sum() > 0 else 0

print(f"\nüéØ MAPE AJUSTADO (excluyendo bonos < $0.10): {mape_valido:.4f}% ‚úÖ")
print(f"   Observaciones v√°lidas: {mask_validos.sum()} de {len(test_illiquid)}")

# Guardar MAPE ajustado para usar en comparaci√≥n de modelos
mape_usd = mape_valido

# An√°lisis por bono
bond_metrics = test_illiquid.groupby('bond').agg({
    'precio_real': 'mean',
    'precio_predicho': 'mean',
    'error_absoluto': 'mean',
    'error_porcentual': 'mean'
}).reset_index()

bond_metrics.columns = ['Bono', 'Precio Real', 'Precio Predicho', 'MAE', 'MAPE %']

print("\nüìä TOP 10 BONOS CON MEJOR PREDICCI√ìN:")
display(bond_metrics.nsmallest(10, 'MAE').style.format({
    'Precio Real': '${:.2f}',
    'Precio Predicho': '${:.2f}',
    'MAE': '${:.2f}',
    'MAPE %': '{:.2f}%'
}).background_gradient(subset=['MAE'], cmap='Greens_r'))

print("\nüìä TOP 10 BONOS CON MAYOR ERROR:")
display(bond_metrics.nlargest(10, 'MAE').style.format({
    'Precio Real': '${:.2f}',
    'Precio Predicho': '${:.2f}',
    'MAE': '${:.2f}',
    'MAPE %': '{:.2f}%'
}).background_gradient(subset=['MAE'], cmap='Reds'))

# Gr√°fico de errores por bono
fig, ax = plt.subplots(figsize=(14, 8))
bond_metrics_sorted = bond_metrics.sort_values('MAE')
ax.barh(bond_metrics_sorted['Bono'], bond_metrics_sorted['MAE'],
        color='coral', alpha=0.7, edgecolor='black')
ax.set_xlabel('MAE (USD)', fontsize=12)
ax.set_ylabel('Bono', fontsize=12)
ax.set_title('Error Absoluto Medio por Bono Il√≠quido', fontweight='bold', fontsize=14)
ax.grid(True, alpha=0.3, axis='x')
plt.tight_layout()
plt.show()

# ============================================================================
# AN√ÅLISIS DE CASOS ESPEC√çFICOS
# ============================================================================

print("\nüéØ PASO 12: AN√ÅLISIS DE CASOS ESPEC√çFICOS")
print("="*60)

# Seleccionar bonos con mejor y peor predicci√≥n
best_bond = bond_metrics.nsmallest(1, 'MAE')['Bono'].iloc[0]
worst_bond = bond_metrics.nlargest(1, 'MAE')['Bono'].iloc[0]

print(f"Mejor predicci√≥n: {best_bond}")
print(f"Peor predicci√≥n: {worst_bond}")

# Graficar series temporales con predicciones
fig, axes = plt.subplots(2, 1, figsize=(14, 10))

for idx, bond in enumerate([best_bond, worst_bond]):
    df_bond = test_illiquid[test_illiquid['bond'] == bond].sort_values('fecha')

    axes[idx].plot(df_bond['fecha'], df_bond['precio_real'],
                   'o-', label='Precio Real', linewidth=2, markersize=6)
    axes[idx].plot(df_bond['fecha'], df_bond['precio_predicho'],
                   's--', label='Precio Predicho', linewidth=2, markersize=6, alpha=0.7)

    mae_bond = df_bond['error_absoluto'].mean()
    axes[idx].set_title(f'{bond} - MAE: ${mae_bond:.2f}',
                       fontweight='bold', fontsize=12)
    axes[idx].set_xlabel('Fecha')
    axes[idx].set_ylabel('Precio (USD)')
    axes[idx].legend()
    axes[idx].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# ============================================================================
# RESUMEN EJECUTIVO
# ============================================================================

print("\n" + "="*80)
print(" "*25 + "RESUMEN EJECUTIVO")
print("="*80)

print("\nüìä DATOS PROCESADOS:")
print(f"   Total bonos analizados: {df_long['bond'].nunique()}")
print(f"   Per√≠odo: {df_long['fecha'].min().date()} a {df_long['fecha'].max().date()}")
print(f"   Total observaciones: {len(df_long):,}")

print("\nüè∑Ô∏è CLASIFICACI√ìN DE BONOS:")
print(f"   L√≠quidos (‚â•70% cobertura): {len(liquid_bonds)}")
print(f"   Intermedios: {len(intermediate_bonds)}")
print(f"   Il√≠quidos (<30% cobertura): {len(illiquid_bonds)}")

print("\nüéØ OBJETIVO ALCANZADO:")
print(f"   Bonos il√≠quidos evaluados: {test_illiquid['bond'].nunique()}")
print(f"   Observaciones evaluadas: {len(test_illiquid):,}")

print("\nü§ñ MODELOS ENTRENADOS:")
for name in models.keys():
    print(f"   ‚úì {name}")

print("\nüèÜ RESULTADOS FINALES EN BONOS IL√çQUIDOS:")
display(df_comparison.style.format({
    'MAE': '${:.2f}',
    'RMSE': '${:.2f}',
    'MAPE': '{:.2f}%'
}).set_properties(**{'font-weight': 'bold'}, subset=['Modelo']))

# Tabla formateada para conclusiones acad√©micas
print("\n" + "="*80)
print("üìä TABLA RESUMIDA PARA REPORTE (MAPE ajustado ‚â•$0.10)")
print("="*80)
print("\n{:<20} {:>15} {:>15} {:>20}".format("Modelo", "MAE (PES)", "RMSE (PES)", "MAPE ajustado (%)"))
print("-" * 80)
for idx, row in df_comparison.iterrows():
    print("{:<20} {:>15.4f} {:>15.4f} {:>20.4f}".format(
        row['Modelo'],
        row['MAE'],
        row['RMSE'],
        row['MAPE']
    ))
print("="*80)
print(f"Nota: MAPE calculado excluyendo {mask_muy_baratos.sum()} bonos con precios < $0.10")
print("="*80)

print("\nüí° CONCLUSIONES PRINCIPALES:")
print(f"   ‚Ä¢ Mejor modelo por MAE: {best_model_mae} (${df_comparison.loc[df_comparison['Modelo']==best_model_mae, 'MAE'].iloc[0]:.4f})")
print(f"   ‚Ä¢ Error promedio: ${df_comparison['MAE'].mean():.4f}")
print(f"   ‚Ä¢ MAPE ajustado promedio: {df_comparison['MAPE'].mean():.4f}%")

print("\nüìà INTERPRETACI√ìN:")

mape_min = df_comparison['MAPE'].min()
if mape_min < 0.1:
    print(f"   ‚úÖ Error porcentual excepcional (MAPE < 0.1%)")
    print(f"   ‚úÖ Precisi√≥n: Error menor al {mape_min:.4f}% del valor real")
elif mape_min < 1:
    print(f"   ‚úÖ Error porcentual muy bajo (MAPE < 1%)")
    print(f"   ‚úÖ Precisi√≥n: Error menor al {mape_min:.2f}% del valor real")
elif mape_min < 5:
    print("   ‚úÖ Error porcentual bajo (MAPE < 5%)")
elif mape_min < 10:
    print("   ‚úÖ Error porcentual aceptable (MAPE < 10%)")
else:
    print("   ‚ö†Ô∏è Error porcentual significativo - revisar outliers")

print("\nüìÅ EXPORTACI√ìN DE RESULTADOS:")

# Guardar resultados
test_illiquid[['fecha', 'bond', 'precio_real', 'precio_predicho',
               'error_absoluto', 'error_porcentual']].to_csv(
    'predicciones_bonos_iliquidos.csv', index=False
)
print("   ‚úì predicciones_bonos_iliquidos.csv")

bond_metrics.to_csv('metricas_por_bono.csv', index=False)
print("   ‚úì metricas_por_bono.csv")

df_comparison.to_csv('comparacion_modelos.csv', index=False)
print("   ‚úì comparacion_modelos.csv")

print("\n‚úÖ PIPELINE COMPLETADO EXITOSAMENTE")
print("="*80 + "\n")

# ============================================================================
# OPCIONAL: GUARDAR MODELOS
# ============================================================================

print("\nüíæ GUARDANDO MODELOS ENTRENADOS...")

import pickle

for name, model in models.items():
    filename = f"modelo_{name.lower().replace(' ', '_')}.pkl"
    with open(filename, 'wb') as f:
        pickle.dump(model, f)
    print(f"   ‚úì {filename}")

print("\n‚úÖ Modelos guardados.")

# ============================================================================
# OPCIONAL: PREDICCI√ìN INTERACTIVA
# ============================================================================

print("\n" + "="*80)
print(" "*20 + "FUNCI√ìN DE PREDICCI√ìN INTERACTIVA")
print("="*80)

def predecir_bono_iliquido(bond_name, fecha):
    """
    Predice el precio de un bono il√≠quido en una fecha espec√≠fica.

    Args:
        bond_name (str): C√≥digo del bono (ej: 'EF25D')
        fecha (str): Fecha en formato 'YYYY-MM-DD'
    """
    # Buscar datos del bono en esa fecha
    fecha_dt = pd.to_datetime(fecha)

    df_bond = df_features[
        (df_features['bond'] == bond_name) &
        (df_features['fecha'] == fecha_dt)
    ]

    if len(df_bond) == 0:
        print(f"‚ö†Ô∏è No hay datos para {bond_name} en {fecha}")
        return None

    X = df_bond[feature_cols]

    print(f"\nüéØ PREDICCI√ìN PARA {bond_name} - {fecha}")
    print("="*60)

    if bond_name in illiquid_bonds:
        print(f"Categor√≠a: üî¥ IL√çQUIDO")
    elif bond_name in liquid_bonds:
        print(f"Categor√≠a: üü¢ L√çQUIDO")
    else:
        print(f"Categor√≠a: üü° INTERMEDIO")

    print(f"\nPrecio real: ${df_bond['target'].iloc[0]:.2f}")
    print(f"\nPredicciones por modelo:")

    for name, model in models.items():
        pred = model.predict(X)[0]
        error = abs(df_bond['target'].iloc[0] - pred)
        print(f"   {name:15s}: ${pred:7.2f} (error: ${error:.2f})")

    return {
        'precio_real': df_bond['target'].iloc[0],
        'predicciones': {name: model.predict(X)[0] for name, model in models.items()}
    }

print("\nüí° Ejemplo de uso:")
print("   predecir_bono_iliquido('EF25D', '2024-10-15')")

# Descomentar para ejecutar ejemplo:
# predecir_bono_iliquido('EF25D', '2024-10-15')

# ============================================================================
# FIN DEL NOTEBOOK
# ============================================================================

print("\n" + "="*80)
print(" "*25 + "¬°AN√ÅLISIS COMPLETADO!")
print("="*80)
print("\nEste notebook ha ejecutado todo el pipeline de Machine Learning para")
print("estimar precios de bonos il√≠quidos argentinos.")
print("\nResultados guardados en archivos CSV para an√°lisis posterior.")
print("="*80)
