# -*- coding: utf-8 -*-
"""Implementaci√≥n algoritmos regresion sobre DataSet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1utbcpRztB4beZLjoHbA1JL4c52qcK4vI

# Implementaci√≥n de Algoritmos
"""

# ============================================================================
# TRABAJO FINAL: ESTIMACI√ìN DE PRECIOS DE BONOS IL√çQUIDOS ARGENTINOS
# Autor: David Acevedo
# Licenciatura en Ciencias de Datos
# ============================================================================

"""
Este notebook implementa un pipeline completo de Machine Learning para estimar
precios de bonos il√≠quidos en el mercado argentino usando:
- Decision Trees
- Random Forest
- XGBoost

INSTRUCCIONES:
1. Sube el archivo 'historico_bonos_en_un_solo_archivo.xlsx' a Colab
2. Ejecuta todas las celdas en orden (Runtime > Run all)
3. Los gr√°ficos y resultados se mostrar√°n autom√°ticamente
"""

# ============================================================================
# CELDA 1: INSTALACI√ìN DE DEPENDENCIAS
# ============================================================================

print("üì¶ Instalando dependencias...")
!pip install -q xgboost openpyxl
print("‚úÖ Dependencias instaladas")

# ============================================================================
# CELDA 2: IMPORTACI√ìN DE LIBRER√çAS
# ============================================================================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

# Machine Learning
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
import xgboost as xgb
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.model_selection import GridSearchCV
import joblib

# Configuraci√≥n visual
plt.style.use('seaborn-v0_8-darkgrid')
sns.set_palette("husl")

print("‚úÖ Librer√≠as importadas")
print(f"üìÖ Fecha de ejecuci√≥n: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

# ============================================================================
# CELDA 3: CLASE PARA CARGA DE DATOS
# ============================================================================

class BondDataLoader:
    """Carga y preprocesamiento de datos de bonos argentinos."""

    def __init__(self, filepath):
        self.filepath = filepath
        self.df_raw = None
        self.df_long = None

    def load_data(self):
        """Carga datos desde Excel."""
        print("üîÑ Cargando datos desde Excel...")
        self.df_raw = pd.read_excel(self.filepath)
        print(f"‚úÖ {self.df_raw.shape[0]} filas, {self.df_raw.shape[1]} columnas")
        return self.df_raw

    def transform_to_long_format(self):
        """Transforma de formato ancho a largo."""
        print("üîÑ Transformando a formato largo...")

        records = []
        for idx, row in self.df_raw.iterrows():
            fecha = row['fecha']

            for col in self.df_raw.columns:
                if col == 'fecha' or 'historico_' not in col:
                    continue

                parts = col.split('_')
                if len(parts) >= 3:
                    bond_name = parts[1]
                    metric = '_'.join(parts[2:])

                    if metric == 'ultimoPrecio':
                        precio_col = col
                        ops_col = f'historico_{bond_name}_cantidadOperaciones'

                        precio = row.get(precio_col)
                        operaciones = row.get(ops_col)

                        precio = float(precio) if pd.notna(precio) and precio != '' else None
                        operaciones = float(operaciones) if pd.notna(operaciones) and operaciones != '' else None

                        records.append({
                            'fecha': fecha,
                            'bond': bond_name,
                            'precio': precio,
                            'operaciones': operaciones
                        })

        self.df_long = pd.DataFrame(records)
        self.df_long['fecha'] = pd.to_datetime(self.df_long['fecha'])
        self.df_long = self.df_long.drop_duplicates()

        print(f"‚úÖ Formato largo: {len(self.df_long):,} observaciones")
        return self.df_long

    def calculate_liquidity_metrics(self):
        """Calcula m√©tricas de liquidez por bono."""
        print("üîÑ Calculando m√©tricas de liquidez...")

        liquidity_metrics = []
        for bond in self.df_long['bond'].unique():
            df_bond = self.df_long[self.df_long['bond'] == bond]

            total_days = len(df_bond)
            days_with_price = df_bond['precio'].notna().sum()
            days_with_ops = (df_bond['operaciones'] > 0).sum()

            liquidity_metrics.append({
                'bond': bond,
                'total_days': total_days,
                'days_with_price': days_with_price,
                'price_coverage': (days_with_price / total_days) * 100,
                'total_operations': df_bond['operaciones'].sum(),
                'avg_price': df_bond['precio'].mean()
            })

        df_liquidity = pd.DataFrame(liquidity_metrics)
        df_liquidity = df_liquidity.sort_values('price_coverage', ascending=False)

        print(f"‚úÖ M√©tricas para {len(df_liquidity)} bonos")
        return df_liquidity

print("‚úÖ Clase BondDataLoader definida")

# ============================================================================
# CELDA 4: CLASE PARA AN√ÅLISIS EXPLORATORIO
# ============================================================================

class BondEDA:
    """An√°lisis exploratorio de datos de bonos."""

    def __init__(self, df_long, df_liquidity):
        self.df_long = df_long
        self.df_liquidity = df_liquidity

    def plot_liquidity_distribution(self):
        """Gr√°fico de distribuci√≥n de liquidez."""
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))

        # Histograma de cobertura
        axes[0, 0].hist(self.df_liquidity['price_coverage'], bins=30,
                       color='steelblue', edgecolor='black', alpha=0.7)
        axes[0, 0].axvline(70, color='green', linestyle='--', label='L√≠quido (70%)', linewidth=2)
        axes[0, 0].axvline(30, color='red', linestyle='--', label='Il√≠quido (30%)', linewidth=2)
        axes[0, 0].set_xlabel('Cobertura de Precios (%)')
        axes[0, 0].set_ylabel('Frecuencia')
        axes[0, 0].set_title('Distribuci√≥n de Cobertura de Precios', fontweight='bold')
        axes[0, 0].legend()
        axes[0, 0].grid(True, alpha=0.3)

        # Operaciones totales
        axes[0, 1].hist(np.log10(self.df_liquidity['total_operations'] + 1),
                       bins=30, color='coral', edgecolor='black', alpha=0.7)
        axes[0, 1].set_xlabel('log10(Total Operaciones + 1)')
        axes[0, 1].set_ylabel('Frecuencia')
        axes[0, 1].set_title('Distribuci√≥n de Volumen', fontweight='bold')
        axes[0, 1].grid(True, alpha=0.3)

        # Scatter
        scatter = axes[1, 0].scatter(self.df_liquidity['price_coverage'],
                                     self.df_liquidity['total_operations'],
                                     c=self.df_liquidity['price_coverage'],
                                     cmap='viridis', s=80, alpha=0.6)
        axes[1, 0].set_xlabel('Cobertura (%)')
        axes[1, 0].set_ylabel('Total Operaciones')
        axes[1, 0].set_title('Cobertura vs Volumen', fontweight='bold')
        axes[1, 0].set_yscale('log')
        axes[1, 0].grid(True, alpha=0.3)
        plt.colorbar(scatter, ax=axes[1, 0])

        # Estad√≠sticas
        axes[1, 1].axis('off')
        stats_text = f"""
        ESTAD√çSTICAS GENERALES

        Total bonos: {len(self.df_liquidity)}
        Cobertura promedio: {self.df_liquidity['price_coverage'].mean():.1f}%
        Cobertura mediana: {self.df_liquidity['price_coverage'].median():.1f}%

        Bonos l√≠quidos (‚â•70%): {(self.df_liquidity['price_coverage'] >= 70).sum()}
        Bonos il√≠quidos (<30%): {(self.df_liquidity['price_coverage'] < 30).sum()}
        """
        axes[1, 1].text(0.1, 0.5, stats_text, fontsize=12, family='monospace',
                       verticalalignment='center')

        plt.tight_layout()
        plt.show()

    def plot_time_series_sample(self, bonds, title="Series Temporales"):
        """Gr√°fica series de tiempo."""
        n_bonds = len(bonds)
        fig, axes = plt.subplots(n_bonds, 1, figsize=(14, 4*n_bonds), sharex=True)

        if n_bonds == 1:
            axes = [axes]

        for idx, bond in enumerate(bonds):
            df_bond = self.df_long[self.df_long['bond'] == bond].sort_values('fecha')

            axes[idx].plot(df_bond['fecha'], df_bond['precio'],
                          linewidth=1.5, color='steelblue', label='Precio')

            df_missing = df_bond[df_bond['precio'].isna()]
            if len(df_missing) > 0:
                axes[idx].scatter(df_missing['fecha'],
                                 [axes[idx].get_ylim()[1]*0.95]*len(df_missing),
                                 color='red', marker='v', s=20, alpha=0.3,
                                 label='Sin cotizaci√≥n')

            liq_info = self.df_liquidity[self.df_liquidity['bond'] == bond].iloc[0]
            axes[idx].set_title(f'{bond} - Cobertura: {liq_info["price_coverage"]:.1f}%',
                              fontweight='bold')
            axes[idx].set_ylabel('Precio (USD)')
            axes[idx].legend()
            axes[idx].grid(True, alpha=0.3)

        axes[-1].set_xlabel('Fecha')
        plt.tight_layout()
        plt.show()

print("‚úÖ Clase BondEDA definida")

# ============================================================================
# CELDA 5: CLASE PARA FEATURE ENGINEERING
# ============================================================================

class BondFeatureEngineer:
    """Ingenier√≠a de features para modelos ML."""

    def __init__(self, df_long, liquid_bonds):
        self.df_long = df_long.copy()
        self.liquid_bonds = liquid_bonds

    def create_features(self):
        """Crea todos los features necesarios."""
        print("üîÑ Creando features...")

        df = self.df_long.sort_values(['bond', 'fecha'])

        # Features por bono
        for bond in df['bond'].unique():
            mask = df['bond'] == bond

            # Lags
            df.loc[mask, 'precio_lag1'] = df.loc[mask, 'precio'].shift(1)

            # Promedios m√≥viles
            df.loc[mask, 'precio_ma7'] = df.loc[mask, 'precio'].rolling(7, min_periods=1).mean()
            df.loc[mask, 'precio_ma30'] = df.loc[mask, 'precio'].rolling(30, min_periods=1).mean()

            # Volatilidad
            df.loc[mask, 'precio_std7'] = df.loc[mask, 'precio'].rolling(7, min_periods=1).std()

            # Retorno
            df.loc[mask, 'retorno_diario'] = df.loc[mask, 'precio'].pct_change()

        # Features de mercado (bonos l√≠quidos)
        df_liquid = df[df['bond'].isin(self.liquid_bonds)]
        market_features = df_liquid.groupby('fecha').agg({
            'precio': ['mean', 'std'],
            'operaciones': 'sum'
        }).reset_index()
        market_features.columns = ['fecha', 'mercado_precio_mean', 'mercado_precio_std', 'mercado_ops']

        df = df.merge(market_features, on='fecha', how='left')

        # Features temporales
        df['mes'] = df['fecha'].dt.month
        df['dia_semana'] = df['fecha'].dt.dayofweek

        # Caracter√≠sticas del bono
        df['es_liquido'] = df['bond'].isin(self.liquid_bonds).astype(int)

        # Target
        df['target'] = df['precio']

        print(f"‚úÖ Features creados")
        return df

print("‚úÖ Clase BondFeatureEngineer definida")

# ============================================================================
# CELDA 6: CLASE PARA MODELADO
# ============================================================================

class BondPriceModel:
    """Modelo de predicci√≥n de precios de bonos."""

    def __init__(self, model_type='random_forest'):
        self.model_type = model_type
        self.model = None
        self.feature_importance = None

    def train(self, X_train, y_train, X_val=None, y_val=None, params=None):
        """Entrena el modelo."""
        print(f"\nüéØ Entrenando: {self.model_type.upper()}")

        if params is None:
            params = {}

        if self.model_type == 'decision_tree':
            default = {'max_depth': 10, 'min_samples_split': 50, 'random_state': 42}
            default.update(params)
            self.model = DecisionTreeRegressor(**default)

        elif self.model_type == 'random_forest':
            default = {'n_estimators': 100, 'max_depth': 15, 'min_samples_split': 20,
                      'random_state': 42, 'n_jobs': -1}
            default.update(params)
            self.model = RandomForestRegressor(**default)

        elif self.model_type == 'xgboost':
            default = {'n_estimators': 100, 'max_depth': 6, 'learning_rate': 0.1,
                      'random_state': 42, 'n_jobs': -1}
            default.update(params)
            self.model = xgb.XGBRegressor(**default)

        self.model.fit(X_train, y_train)

        if hasattr(self.model, 'feature_importances_'):
            self.feature_importance = pd.DataFrame({
                'feature': X_train.columns,
                'importance': self.model.feature_importances_
            }).sort_values('importance', ascending=False)

        # Evaluar
        y_train_pred = self.model.predict(X_train)
        train_mae = mean_absolute_error(y_train, y_train_pred)
        train_r2 = r2_score(y_train, y_train_pred)
        print(f"   Train MAE: ${train_mae:.2f} | R¬≤: {train_r2:.4f}")

        if X_val is not None:
            y_val_pred = self.model.predict(X_val)
            val_mae = mean_absolute_error(y_val, y_val_pred)
            val_r2 = r2_score(y_val, y_val_pred)
            print(f"   Val MAE:   ${val_mae:.2f} | R¬≤: {val_r2:.4f}")

    def predict(self, X):
        """Realiza predicciones."""
        return self.model.predict(X)

    def evaluate(self, X, y, name="Test"):
        """Eval√∫a el modelo."""
        y_pred = self.predict(X)
        mae = mean_absolute_error(y, y_pred)
        rmse = np.sqrt(mean_squared_error(y, y_pred))
        r2 = r2_score(y, y_pred)
        mape = np.mean(np.abs((y - y_pred) / (y + 1e-10))) * 100

        print(f"\nüìä M√©tricas en {name}:")
        print(f"   MAE:  ${mae:.2f}")
        print(f"   RMSE: ${rmse:.2f}")
        print(f"   R¬≤:    {r2:.4f}")
        print(f"   MAPE:  {mape:.2f}%")

        return {'MAE': mae, 'RMSE': rmse, 'R2': r2, 'MAPE': mape}

    def plot_predictions(self, X, y_true, title="Predicciones"):
        """Gr√°fica predicciones vs reales."""
        y_pred = self.predict(X)

        fig, axes = plt.subplots(1, 2, figsize=(14, 5))

        # Scatter
        axes[0].scatter(y_true, y_pred, alpha=0.5, s=30)
        min_val = min(y_true.min(), y_pred.min())
        max_val = max(y_true.max(), y_pred.max())
        axes[0].plot([min_val, max_val], [min_val, max_val], 'r--', lw=2)
        axes[0].set_xlabel('Precio Real')
        axes[0].set_ylabel('Precio Predicho')
        axes[0].set_title(f'{title} - {self.model_type}', fontweight='bold')
        axes[0].grid(True, alpha=0.3)

        # Residuos
        residuals = y_true - y_pred
        axes[1].hist(residuals, bins=50, color='coral', edgecolor='black', alpha=0.7)
        axes[1].axvline(0, color='red', linestyle='--', lw=2)
        axes[1].set_xlabel('Residuos')
        axes[1].set_ylabel('Frecuencia')
        axes[1].set_title('Distribuci√≥n de Residuos', fontweight='bold')
        axes[1].grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

print("‚úÖ Clase BondPriceModel definida")

# ============================================================================
# TODAS LAS CLASES EST√ÅN DEFINIDAS. AHORA VIENE EL C√ìDIGO PRINCIPAL
# ============================================================================

print("\n" + "="*80)
print(" "*15 + "EJECUCI√ìN DEL PIPELINE COMPLETO")
print("="*80)

# ============================================================================
# CELDA 7: CARGA DE DATOS
# ============================================================================

print("\nüìÇ PASO 1: CARGA DE DATOS")
print("="*60)

# IMPORTANTE: Aseg√∫rate de subir el archivo Excel a Colab primero
FILENAME = 'historico_bonos_en_un_solo_archivo.xlsx'

loader = BondDataLoader(FILENAME)
df_raw = loader.load_data()
df_long = loader.transform_to_long_format()
df_liquidity = loader.calculate_liquidity_metrics()

print(f"\n‚úÖ Datos cargados:")
print(f"   Per√≠odo: {df_long['fecha'].min().date()} a {df_long['fecha'].max().date()}")
print(f"   Total observaciones: {len(df_long):,}")
print(f"   Bonos √∫nicos: {df_long['bond'].nunique()}")

# ============================================================================
# CELDA 8: CLASIFICACI√ìN DE BONOS
# ============================================================================

print("\nüè∑Ô∏è PASO 2: CLASIFICACI√ìN DE BONOS")
print("="*60)

LIQUID_THRESHOLD = 70.0
ILLIQUID_THRESHOLD = 30.0

liquid_bonds = df_liquidity[df_liquidity['price_coverage'] >= LIQUID_THRESHOLD]['bond'].tolist()
illiquid_bonds = df_liquidity[df_liquidity['price_coverage'] < ILLIQUID_THRESHOLD]['bond'].tolist()
intermediate_bonds = df_liquidity[
    (df_liquidity['price_coverage'] >= ILLIQUID_THRESHOLD) &
    (df_liquidity['price_coverage'] < LIQUID_THRESHOLD)
]['bond'].tolist()

print(f"üü¢ Bonos l√≠quidos (‚â•{LIQUID_THRESHOLD}%): {len(liquid_bonds)}")
print(f"üü° Bonos intermedios: {len(intermediate_bonds)}")
print(f"üî¥ Bonos il√≠quidos (<{ILLIQUID_THRESHOLD}%): {len(illiquid_bonds)}")

print(f"\nTop 10 bonos M√ÅS l√≠quidos:")
display(df_liquidity.head(10)[['bond', 'price_coverage', 'total_operations', 'avg_price']])

print(f"\nTop 10 bonos MENOS l√≠quidos:")
display(df_liquidity.tail(10)[['bond', 'price_coverage', 'total_operations', 'avg_price']])

# ============================================================================
# CELDA 9: AN√ÅLISIS EXPLORATORIO
# ============================================================================

print("\nüìä PASO 3: AN√ÅLISIS EXPLORATORIO")
print("="*60)

eda = BondEDA(df_long, df_liquidity)

# Gr√°fico de distribuci√≥n
eda.plot_liquidity_distribution()

# Series temporales de bonos l√≠quidos
print("\nSeries temporales - Bonos l√≠quidos (muestra):")
eda.plot_time_series_sample(liquid_bonds[:3], "Bonos L√≠quidos - Top 3")

# Series temporales de bonos il√≠quidos
print("\nSeries temporales - Bonos il√≠quidos (muestra):")
eda.plot_time_series_sample(illiquid_bonds[:3], "Bonos Il√≠quidos - Muestra")

# ============================================================================
# CELDA 10: FEATURE ENGINEERING
# ============================================================================

print("\nüõ†Ô∏è PASO 4: FEATURE ENGINEERING")
print("="*60)

engineer = BondFeatureEngineer(df_long, liquid_bonds)
df_features = engineer.create_features()

# Eliminar NaN
df_features = df_features.dropna()

print(f"‚úÖ Dataset con features creado: {df_features.shape}")
print(f"   Total features: {len([c for c in df_features.columns if c not in ['fecha', 'bond', 'target']])}")

# ============================================================================
# CELDA 11: DIVISI√ìN TEMPORAL DE DATOS
# ============================================================================

print("\n‚úÇÔ∏è PASO 5: DIVISI√ìN TEMPORAL DEL DATASET")
print("="*60)

VAL_DATE = '2024-07-01'
TEST_DATE = '2024-10-01'

df_features['fecha'] = pd.to_datetime(df_features['fecha'])

# Divisi√≥n temporal
df_train = df_features[df_features['fecha'] < VAL_DATE].copy()
df_val = df_features[(df_features['fecha'] >= VAL_DATE) &
                     (df_features['fecha'] < TEST_DATE)].copy()
df_test = df_features[df_features['fecha'] >= TEST_DATE].copy()

print(f"üìÖ Train: {df_train['fecha'].min().date()} a {df_train['fecha'].max().date()} | {len(df_train):,} obs")
print(f"üìÖ Val:   {df_val['fecha'].min().date()} a {df_val['fecha'].max().date()} | {len(df_val):,} obs")
print(f"üìÖ Test:  {df_test['fecha'].min().date()} a {df_test['fecha'].max().date()} | {len(df_test):,} obs")

# Separar l√≠quidos e il√≠quidos
train_liquid = df_train[df_train['bond'].isin(liquid_bonds)].copy()
val_liquid = df_val[df_val['bond'].isin(liquid_bonds)].copy()
test_illiquid = df_test[df_test['bond'].isin(illiquid_bonds)].copy()

print(f"\nüéØ DATASETS PARA MODELADO:")
print(f"   Train (l√≠quidos): {len(train_liquid):,} obs, {train_liquid['bond'].nunique()} bonos")
print(f"   Val (l√≠quidos): {len(val_liquid):,} obs, {val_liquid['bond'].nunique()} bonos")
print(f"   Test (il√≠quidos): {len(test_illiquid):,} obs, {test_illiquid['bond'].nunique()} bonos")

# ============================================================================
# CELDA 12: PREPARACI√ìN DE FEATURES
# ============================================================================

# Definir columnas de features
exclude_cols = ['fecha', 'bond', 'precio', 'target', 'operaciones']
feature_cols = [col for col in df_features.columns if col not in exclude_cols]

print(f"\nüìã Features para modelado: {len(feature_cols)}")
print("Primeros 10 features:")
for i, feat in enumerate(feature_cols[:10], 1):
    print(f"   {i}. {feat}")

# Preparar X, y
X_train = train_liquid[feature_cols]
y_train = train_liquid['target']

X_val = val_liquid[feature_cols]
y_val = val_liquid['target']

X_test = test_illiquid[feature_cols]
y_test = test_illiquid['target']

print(f"\n‚úÖ Datos preparados para entrenamiento")

# ============================================================================
# CELDA 13: ENTRENAMIENTO DE MODELOS
# ============================================================================

print("\nü§ñ PASO 6: ENTRENAMIENTO DE MODELOS")
print("="*60)

# 1. Decision Tree
print("\n" + "-"*60)
dt_model = BondPriceModel('decision_tree')
dt_model.train(X_train, y_train, X_val, y_val,
               params={'max_depth': 12, 'min_samples_split': 30})

# 2. Random Forest
print("\n" + "-"*60)
rf_model = BondPriceModel('random_forest')
rf_model.train(X_train, y_train, X_val, y_val,
               params={'n_estimators': 150, 'max_depth': 15})

# 3. XGBoost
print("\n" + "-"*60)
xgb_model = BondPriceModel('xgboost')
xgb_model.train(X_train, y_train, X_val, y_val,
                params={'n_estimators': 200, 'max_depth': 6, 'learning_rate': 0.05})

print("\n‚úÖ Todos los modelos entrenados")

# ============================================================================
# CELDA 14: EVALUACI√ìN EN BONOS IL√çQUIDOS
# ============================================================================

print("\nüéØ PASO 7: EVALUACI√ìN EN BONOS IL√çQUIDOS (OBJETIVO PRINCIPAL)")
print("="*60)

print(f"\nDataset de prueba:")
print(f"   Observaciones: {len(X_test):,}")
print(f"   Bonos il√≠quidos √∫nicos: {test_illiquid['bond'].nunique()}")
print(f"   Precio promedio real: ${y_test.mean():.2f}")

# Evaluar cada modelo
models = {
    'Decision Tree': dt_model,
    'Random Forest': rf_model,
    'XGBoost': xgb_model
}

results = {}
for name, model in models.items():
    print(f"\n{'-'*60}")
    metrics = model.evaluate(X_test, y_test, name)
    results[name] = metrics

# ============================================================================
# CELDA 15: COMPARACI√ìN DE MODELOS
# ============================================================================

print("\nüìä PASO 8: COMPARACI√ìN DE MODELOS")
print("="*60)

df_comparison = pd.DataFrame(results).T
df_comparison = df_comparison.reset_index()
df_comparison.columns = ['Modelo', 'MAE', 'RMSE', 'R¬≤', 'MAPE']

print("\nüèÜ TABLA COMPARATIVA:")
display(df_comparison.style.format({
    'MAE': '${:.2f}',
    'RMSE': '${:.2f}',
    'R¬≤': '{:.4f}',
    'MAPE': '{:.2f}%'
}).background_gradient(subset=['R¬≤'], cmap='Greens'))

# Gr√°fico comparativo
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

metrics = ['MAE', 'RMSE', 'R¬≤', 'MAPE']
titles = ['MAE (menor mejor)', 'RMSE (menor mejor)',
         'R¬≤ (mayor mejor)', 'MAPE % (menor mejor)']
colors = ['steelblue', 'coral', 'green', 'purple']

for idx, (metric, title, color) in enumerate(zip(metrics, titles, colors)):
    ax = axes[idx // 2, idx % 2]

    df_plot = df_comparison[['Modelo', metric]].sort_values(
        metric, ascending=(metric != 'R¬≤')
    )

    ax.barh(df_plot['Modelo'], df_plot[metric], color=color, alpha=0.7, edgecolor='black')
    ax.set_xlabel(metric, fontsize=11)
    ax.set_title(title, fontsize=12, fontweight='bold')
    ax.grid(True, alpha=0.3, axis='x')

plt.tight_layout()
plt.show()

# Identificar mejor modelo
best_model_mae = df_comparison.loc[df_comparison['MAE'].idxmin(), 'Modelo']
best_model_r2 = df_comparison.loc[df_comparison['R¬≤'].idxmax(), 'Modelo']

print(f"\nüèÜ MEJORES MODELOS:")
print(f"   Menor MAE: {best_model_mae}")
print(f"   Mayor R¬≤:  {best_model_r2}")

# ============================================================================
# CELDA 16: VISUALIZACI√ìN DE PREDICCIONES
# ============================================================================

print("\nüìà PASO 9: VISUALIZACI√ìN DE PREDICCIONES")
print("="*60)

# Predicciones de cada modelo
for name, model in models.items():
    print(f"\n{name}:")
    model.plot_predictions(X_test, y_test, f"Bonos Il√≠quidos - {name}")

# ============================================================================
# CELDA 17: FEATURE IMPORTANCE
# ============================================================================

print("\nüîç PASO 10: IMPORTANCIA DE FEATURES")
print("="*60)

for name, model in models.items():
    if model.feature_importance is not None:
        print(f"\n{name} - Top 15 Features:")

        top_features = model.feature_importance.head(15)

        fig, ax = plt.subplots(figsize=(10, 6))
        ax.barh(range(len(top_features)), top_features['importance'], color='steelblue')
        ax.set_yticks(range(len(top_features)))
        ax.set_yticklabels(top_features['feature'])
        ax.set_xlabel('Importancia')
        ax.set_title(f'Top 15 Features - {name}', fontweight='bold', fontsize=14)
        ax.invert_yaxis()
        ax.grid(True, alpha=0.3, axis='x')
        plt.tight_layout()
        plt.show()

# ============================================================================
# CELDA 18: AN√ÅLISIS DETALLADO POR BONO
# ============================================================================

print("\nüî¨ PASO 11: AN√ÅLISIS DETALLADO POR BONO")
print("="*60)

# Usar el mejor modelo (Random Forest generalmente)
best_model = rf_model

y_pred = best_model.predict(X_test)

# Agregar predicciones al dataframe
test_illiquid['precio_predicho'] = y_pred
test_illiquid['error_absoluto'] = np.abs(test_illiquid['target'] - y_pred)
test_illiquid['error_porcentual'] = (test_illiquid['error_absoluto'] /
                                     test_illiquid['target']) * 100

# An√°lisis por bono
bond_metrics = test_illiquid.groupby('bond').agg({
    'target': 'mean',
    'precio_predicho': 'mean',
    'error_absoluto': 'mean',
    'error_porcentual': 'mean'
}).reset_index()

bond_metrics.columns = ['Bono', 'Precio Real', 'Precio Predicho', 'MAE', 'MAPE %']

print("\nüìä TOP 10 BONOS CON MEJOR PREDICCI√ìN:")
display(bond_metrics.nsmallest(10, 'MAE').style.format({
    'Precio Real': '${:.2f}',
    'Precio Predicho': '${:.2f}',
    'MAE': '${:.2f}',
    'MAPE %': '{:.2f}%'
}).background_gradient(subset=['MAE'], cmap='Greens_r'))

print("\nüìä TOP 10 BONOS CON MAYOR ERROR:")
display(bond_metrics.nlargest(10, 'MAE').style.format({
    'Precio Real': '${:.2f}',
    'Precio Predicho': '${:.2f}',
    'MAE': '${:.2f}',
    'MAPE %': '{:.2f}%'
}).background_gradient(subset=['MAE'], cmap='Reds'))

# Gr√°fico de errores por bono
fig, ax = plt.subplots(figsize=(14, 8))
bond_metrics_sorted = bond_metrics.sort_values('MAE')
ax.barh(bond_metrics_sorted['Bono'], bond_metrics_sorted['MAE'],
        color='coral', alpha=0.7, edgecolor='black')
ax.set_xlabel('MAE (USD)', fontsize=12)
ax.set_ylabel('Bono', fontsize=12)
ax.set_title('Error Absoluto Medio por Bono Il√≠quido', fontweight='bold', fontsize=14)
ax.grid(True, alpha=0.3, axis='x')
plt.tight_layout()
plt.show()

# ============================================================================
# CELDA 19: AN√ÅLISIS DE CASOS ESPEC√çFICOS
# ============================================================================

print("\nüéØ PASO 12: AN√ÅLISIS DE CASOS ESPEC√çFICOS")
print("="*60)

# Seleccionar bonos con mejor y peor predicci√≥n
best_bond = bond_metrics.nsmallest(1, 'MAE')['Bono'].iloc[0]
worst_bond = bond_metrics.nlargest(1, 'MAE')['Bono'].iloc[0]

print(f"Mejor predicci√≥n: {best_bond}")
print(f"Peor predicci√≥n: {worst_bond}")

# Graficar series temporales con predicciones
fig, axes = plt.subplots(2, 1, figsize=(14, 10))

for idx, bond in enumerate([best_bond, worst_bond]):
    df_bond = test_illiquid[test_illiquid['bond'] == bond].sort_values('fecha')

    axes[idx].plot(df_bond['fecha'], df_bond['target'],
                   'o-', label='Precio Real', linewidth=2, markersize=6)
    axes[idx].plot(df_bond['fecha'], df_bond['precio_predicho'],
                   's--', label='Precio Predicho', linewidth=2, markersize=6, alpha=0.7)

    mae_bond = df_bond['error_absoluto'].mean()
    axes[idx].set_title(f'{bond} - MAE: ${mae_bond:.2f}',
                       fontweight='bold', fontsize=12)
    axes[idx].set_xlabel('Fecha')
    axes[idx].set_ylabel('Precio (USD)')
    axes[idx].legend()
    axes[idx].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# ============================================================================
# CELDA 20: RESUMEN EJECUTIVO
# ============================================================================

print("\n" + "="*80)
print(" "*25 + "RESUMEN EJECUTIVO")
print("="*80)

print("\nüìä DATOS PROCESADOS:")
print(f"   Total bonos analizados: {df_long['bond'].nunique()}")
print(f"   Per√≠odo: {df_long['fecha'].min().date()} a {df_long['fecha'].max().date()}")
print(f"   Total observaciones: {len(df_long):,}")

print("\nüè∑Ô∏è CLASIFICACI√ìN DE BONOS:")
print(f"   L√≠quidos (‚â•70% cobertura): {len(liquid_bonds)}")
print(f"   Intermedios: {len(intermediate_bonds)}")
print(f"   Il√≠quidos (<30% cobertura): {len(illiquid_bonds)}")

print("\nüéØ OBJETIVO ALCANZADO:")
print(f"   Bonos il√≠quidos evaluados: {test_illiquid['bond'].nunique()}")
print(f"   Observaciones evaluadas: {len(test_illiquid):,}")

print("\nü§ñ MODELOS ENTRENADOS:")
for name in models.keys():
    print(f"   ‚úì {name}")

print("\nüèÜ RESULTADOS FINALES EN BONOS IL√çQUIDOS:")
display(df_comparison.style.format({
    'MAE': '${:.2f}',
    'RMSE': '${:.2f}',
    'R¬≤': '{:.4f}',
    'MAPE': '{:.2f}%'
}).set_properties(**{'font-weight': 'bold'}, subset=['Modelo']))

print("\nüí° CONCLUSIONES PRINCIPALES:")
print(f"   ‚Ä¢ Mejor modelo por MAE: {best_model_mae} (${df_comparison.loc[df_comparison['Modelo']==best_model_mae, 'MAE'].iloc[0]:.2f})")
print(f"   ‚Ä¢ Mejor modelo por R¬≤: {best_model_r2} (R¬≤={df_comparison.loc[df_comparison['Modelo']==best_model_r2, 'R¬≤'].iloc[0]:.4f})")
print(f"   ‚Ä¢ Error promedio: ${df_comparison['MAE'].mean():.2f}")
print(f"   ‚Ä¢ Varianza explicada promedio: {df_comparison['R¬≤'].mean():.1%}")

print("\nüìà INTERPRETACI√ìN:")
if df_comparison['R¬≤'].max() > 0.85:
    print("   ‚úÖ Excelente capacidad predictiva (R¬≤ > 0.85)")
elif df_comparison['R¬≤'].max() > 0.70:
    print("   ‚úÖ Buena capacidad predictiva (R¬≤ > 0.70)")
else:
    print("   ‚ö†Ô∏è Capacidad predictiva moderada - considerar m√°s features")

if df_comparison['MAPE'].min() < 5:
    print("   ‚úÖ Error porcentual bajo (MAPE < 5%)")
elif df_comparison['MAPE'].min() < 10:
    print("   ‚úÖ Error porcentual aceptable (MAPE < 10%)")
else:
    print("   ‚ö†Ô∏è Error porcentual significativo - revisar outliers")

print("\nüìÅ EXPORTACI√ìN DE RESULTADOS:")

# Guardar resultados
test_illiquid[['fecha', 'bond', 'target', 'precio_predicho',
               'error_absoluto', 'error_porcentual']].to_csv(
    'predicciones_bonos_iliquidos.csv', index=False
)
print("   ‚úì predicciones_bonos_iliquidos.csv")

bond_metrics.to_csv('metricas_por_bono.csv', index=False)
print("   ‚úì metricas_por_bono.csv")

df_comparison.to_csv('comparacion_modelos.csv', index=False)
print("   ‚úì comparacion_modelos.csv")

print("\n‚úÖ PIPELINE COMPLETADO EXITOSAMENTE")
print("="*80 + "\n")

# ============================================================================
# CELDA 21 (OPCIONAL): GUARDAR MODELOS
# ============================================================================

print("\nüíæ GUARDANDO MODELOS ENTRENADOS...")

import pickle

for name, model in models.items():
    filename = f"modelo_{name.lower().replace(' ', '_')}.pkl"
    with open(filename, 'wb') as f:
        pickle.dump(model, f)
    print(f"   ‚úì {filename}")

print("\n‚úÖ Modelos guardados. Puedes descargarlos desde el explorador de archivos de Colab.")

# ============================================================================
# CELDA 22 (OPCIONAL): PREDICCI√ìN INTERACTIVA
# ============================================================================

print("\n" + "="*80)
print(" "*20 + "FUNCI√ìN DE PREDICCI√ìN INTERACTIVA")
print("="*80)

def predecir_bono_iliquido(bond_name, fecha):
    """
    Predice el precio de un bono il√≠quido en una fecha espec√≠fica.

    Args:
        bond_name (str): C√≥digo del bono (ej: 'EF25D')
        fecha (str): Fecha en formato 'YYYY-MM-DD'
    """
    # Buscar datos del bono en esa fecha
    fecha_dt = pd.to_datetime(fecha)

    df_bond = df_features[
        (df_features['bond'] == bond_name) &
        (df_features['fecha'] == fecha_dt)
    ]

    if len(df_bond) == 0:
        print(f"‚ö†Ô∏è No hay datos para {bond_name} en {fecha}")
        return None

    X = df_bond[feature_cols]

    print(f"\nüéØ PREDICCI√ìN PARA {bond_name} - {fecha}")
    print("="*60)

    if bond_name in illiquid_bonds:
        print(f"Categor√≠a: üî¥ IL√çQUIDO")
    elif bond_name in liquid_bonds:
        print(f"Categor√≠a: üü¢ L√çQUIDO")
    else:
        print(f"Categor√≠a: üü° INTERMEDIO")

    print(f"\nPrecio real: ${df_bond['target'].iloc[0]:.2f}")
    print(f"\nPredicciones por modelo:")

    for name, model in models.items():
        pred = model.predict(X)[0]
        error = abs(df_bond['target'].iloc[0] - pred)
        print(f"   {name:15s}: ${pred:7.2f} (error: ${error:.2f})")

    return {
        'precio_real': df_bond['target'].iloc[0],
        'predicciones': {name: model.predict(X)[0] for name, model in models.items()}
    }

print("\nüí° Ejemplo de uso:")
print("   predecir_bono_iliquido('EF25D', '2024-10-15')")

# ============================================================================
# FIN DEL NOTEBOOK
# ============================================================================

print("\n" + "="*80)
print(" "*25 + "¬°AN√ÅLISIS COMPLETADO!")
print("="*80)
print("\nEste notebook ha ejecutado todo el pipeline de Machine Learning para")
print("estimar precios de bonos il√≠quidos argentinos.")
print("\nResultados guardados en archivos CSV para an√°lisis posterior.")
print("\nüìß Para consultas: david.acevedo@ejemplo.com")
print("="*80)

"""# Graficos secci√≥n 4.2

## Script 4.2.1: Caracterizaci√≥n del Dataset
"""